
Intro
=====

A data binding framework that generates type-safe binding classes.

Or, OGNL with no strings.

A test case:

    public void testEmployerThroughEmployee() {
        Employer er = new Employer();
        er.name = "at&t";

        Employee ee = new Employee();
        ee.name = "bob";
        ee.employer = er;

        EmployeeBinding eb = new EmployeeBinding(ee); // EmployeeBinding is generated by bindgen
        eb.name(); // name() returns a StringBinding instance instead of the actual name String

        // During rendering TextBox calls StringBinding.get()
        Assert.assertEquals("bob", new TextBox(eb.name()).toString());
        Assert.assertEquals("at&t", new TextBox(eb.employer().name()).toString());

        // During POST procesing TextBox calls StringBinding.set()
        new TextBox(eb.name()).set("newBob");
        new TextBox(eb.employer().name()).set("newAt&t");
        Assert.assertEquals("newBob", ee.name);
        Assert.assertEquals("newAt&t", er.name);
    }

The point being that `eb.employer().name()` does not immediately return the value of `name`, but instead returns a `StringBinding` that the web framework can bind values into/out of as it serves the request.

Annotations
===========

Bindgen is implemented as JDK6 annotation processor. When configured in your IDE (e.g. with project-specific settings in Eclipse), as soon as you add a `@Bindable` annotation to a class `Foo`, and hit save, the IDE immediately invokes the [BindgenAnnotationProcessor][2] behind the scenes and `FooBinding` is created.

[2]: master/bindgen/src/org/exigencecorp/bindgen/processor/BindgenAnnotationProcessor.java

Another Example
===============

This is a spike from a [Click][1]-like web framework I'm hacking around on:

    @Bindable
    public class HomePage extends AbstractPage {

        public Form form = new Form("Login");
        public String username = "blah";
        public String password;
        private HomePageBinding bind = new HomePageBinding(this);

        @Override
        public void onInit() {
            this.form.add(new TextField(this.bind.username()));
            this.form.add(new TextField(this.bind.password()));
            this.form.add(new SubmitField(this.bind.submit()));
        }

        public void submit() {
            // do stuff with this.username and this.password
        }
    }

The `HomePageBinding` class is auto-generated because of the `@Bindable` annotation on the `HomePage` class.

When the form POSTs, the TextFields call the `Binding.set` methods with their form values, which populates the `this.username` and `this.password` fields.

Fun things like type conversion using `Binding.getType()` method to go from strings -> whatever would be possible too.

[1]: http://click.sf.net

Gotchas
=======

* Eclipse: Annotating packages as `@Bindable` does not work until 3.5-M5
* Eclipse: Clean builds cause compile errors if your `Foo` class references its own `FooBinding` (see [263985][3]) *and* you declare `FooBinding` as a field/method return--for now declaring `FooBinding` inside a method as a local variable works fine
* IntelliJ: Does not support annotation processors (from what I can tell)

[3]: https://bugs.eclipse.org/bugs/show_bug.cgi?id=263985

Todo
====

* Currently only `void methodName()` methods are recognized and wrapped as `Runnables`--it would be nice to give parameters to the `@Bindable` annotation for other method patterns to look for, e.g.:

A block:

    public interface TransactionBlock {
        boolean go(Transaction txn);
    }

With a usage of:

    @Bindable(recognize = { TransactionBlock.class })
    public class Foo {
        public boolean someMethod(Transaction txn) {
            ...
        }
    }

Then doing:

    new FooBinding(foo).someMethod()

Would return a `TransactionBlock` instance bound to `foo` that you could pass around and call `go(txn)` against later.

* No real tests--currently I just make changes and see if the `tests/example` use cases still work. Some (ugh) mock meta models/something might be more appropriate to get true unit test coverage going

* Somehow suppress the deprecation/raw type warnings that result from bindgen traversing into old APIs (e.g. the servlet API)

* Add jarjar so that the dependencies included in `bindgen.jar` do not cause conflicts

* Figure out configuration--e.g. `@Bindable(YourConfiguration.class)`, hopefully at processor time we can look that up and read/infer meta data out of it.

* Recognize `hasErrors`, `toString`, etc., along with just getters/setters

* Support extension methods, e.g. StringBinding could have extra methods like `length()`, `substring()`, etc., ideally configurable

* Does inheritance work? E.g. `BaseBinding Base.getBinding()`, then `SubBinding Sub.getBinding()`, `SubBinding` would need to extend `BaseBinding`--might be tricky

* Optional null-safe get/set, e.g. `eb.employer().name()` with a null `employer` could have `get()` return `null` and not NPE and `set()` could create a `new Employer()` to then call `setName()` on to again avoid the NPE

